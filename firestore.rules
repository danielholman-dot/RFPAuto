/**
 * @fileoverview Firestore Security Rules for the MARCUS Automation Suite.
 *
 * Core Philosophy:
 * This ruleset enforces a hybrid security model with user-specific data,
 * shared access control, and public read-only data. It prioritizes
 * authorization independence by denormalizing access control data directly
 * onto documents, avoiding costly `get()` operations.
 *
 * Data Structure:
 * - /users/{userId}: Stores private user profile information. Access is
 *   strictly limited to the user themselves.
 * - /projects/{projectId}: Stores project data, including a 'members' map
 *   for collaborative access.
 * - /projects/{projectId}/subcollections: These subcollections (e.g.,
 *   eoiEmails, rfpEmails, rfps) inherit the 'members' map from their parent
 *   project for authorization.
 * - /contractors/{contractorId}: Stores public contractor data.
 * - /contractors/{contractorId}/proposals/{proposalId}: Stores proposals
 *   submitted by contractors. Contractor owns the proposal, with projectId denormalized.
 * - /metroCodes/{metroCodeId}: Stores public metro code data.
 *
 * Key Security Decisions:
 * - User data is strictly private and accessible only to the user themselves.
 * - Project access is managed through a 'members' map on the project document,
 *   defining user roles (e.g., owner, editor, viewer).
 * - Subcollections of projects inherit the project's 'members' map for
 *   consistent authorization.
 * - Contractors and MetroCodes are publicly readable.
 * - Listing of users is disallowed to protect privacy.
 *
 * Denormalization for Authorization:
 * The 'members' map on /projects/{projectId} is copied to documents in its
 * subcollections. This allows rules to check membership without needing
 * additional reads. Proposals are also denormalized with the project ID.
 *
 * Structural Segregation:
 * Public data (MetroCodes, Contractors) is stored in top-level collections
 * with public read access. Private data (User profiles) is stored under
 * /users/{userId} with strict ownership checks.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the user is signed in.
     * @return {boolean} True if the user is signed in, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user is the owner of the resource.
     * @param {string} userId - The user ID to compare against the authenticated user's ID.
     * @return {boolean} True if the user is the owner, false otherwise.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Checks if the authenticated user is the owner of the resource and it exists.
     * @param {string} userId - The user ID to compare against the authenticated user's ID.
     * @return {boolean} True if the user is the owner and the resource exists, false otherwise.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * @description Checks if the authenticated user is a member of the project.
     * @param {map} members - The members map of the project.
     * @return {boolean} True if the user is a member, false otherwise.
     */
    function isProjectMember(members) {
      return isSignedIn() && members[request.auth.uid] != null;
    }

    /**
     * @description Checks if the authenticated user is an editor of the project.
     * @param {map} members - The members map of the project.
     * @return {boolean} True if the user is an editor, false otherwise.
     */
    function isProjectEditor(members) {
      return isSignedIn() && members[request.auth.uid] == 'editor';
    }

    /**
     * @description Checks if the authenticated user is an owner of the project.
     * @param {map} members - The members map of the project.
     * @return {boolean} True if the user is an owner, false otherwise.
     */
    function isProjectOwner(members) {
      return isSignedIn() && members[request.auth.uid] == 'owner';
    }

    /**
     * @description Defines a read-only role for the project.
     * @param {map} members - The members map of the project.
     * @return {boolean} True if the user is an owner, editor, or viewer; false otherwise.
     */
    function isProjectReadOnly(members) {
        return isSignedIn() && (members[request.auth.uid] == 'owner' || members[request.auth.uid] == 'editor' || members[request.auth.uid] == 'viewer');
    }

    /**
     * @description
     * This rule governs access to user profile data.
     * Only the authenticated user can read or write their own profile.
     * @path /users/{userId}
     * @allow (create) User A can create their profile if their auth UID matches the document ID.
     * @allow (get) User A can read their own profile data.
     * @allow (update) User A can update their own profile data.
     * @allow (delete) User A can delete their own profile data.
     * @deny (create) User A cannot create a profile for User B.
     * @deny (get) User A cannot read User B's profile data.
     * @deny (update) User A cannot update User B's profile data.
     * @deny (delete) User A cannot delete User B's profile data.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false; // Listing users is not permitted

      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description
     * This rule governs access to project data.
     * Access is controlled via a 'members' map on the project document.
     * @path /projects/{projectId}
     * @allow (create) User A can create a project.
     * @allow (get) User A can read a project if they are a member.
     * @allow (update) User A can update a project if they are an editor or owner.
     * @allow (delete) User A can delete a project if they are an owner.
     * @deny (create) User A cannot create a project without proper authorization.
     * @deny (get) User A cannot read a project if they are not a member.
     * @deny (update) User A cannot update a project if they are not an editor or owner.
     * @deny (delete) User A cannot delete a project if they are not an owner.
     * @principle Enforces role-based access control for project collaboration.
     */
    match /projects/{projectId} {
      allow get: if isProjectReadOnly(resource.data.members);
      allow list: if isSignedIn(); // Anyone signed in can list projects (adjust as needed)

      allow create: if isSignedIn(); // Adjust as needed; consider adding role-based access
      allow update: if isExistingOwner(projectId) && isProjectEditor(resource.data.members);
      allow delete: if isExistingOwner(projectId) && isProjectOwner(resource.data.members);
    }

    /**
     * @description
     * This rule governs access to EOI email data within a project.
     * Access is controlled via the 'members' map inherited from the parent project.
     * @path /projects/{projectId}/eoiEmails/{eoiEmailId}
     * @allow (create) User A can create an EOI email if they are an editor or owner of the project.
     * @allow (get) User A can read an EOI email if they are a member of the project.
     * @allow (update) User A can update an EOI email if they are an editor or owner of the project.
     * @allow (delete) User A can delete an EOI email if they are an owner of the project.
     * @deny (create) User A cannot create an EOI email if they are not an editor or owner of the project.
     * @deny (get) User A cannot read an EOI email if they are not a member of the project.
     * @deny (update) User A cannot update an EOI email if they are not an editor or owner of the project.
     * @deny (delete) User A cannot delete an EOI email if they are not an owner of the project.
     * @principle Enforces consistent access control based on project membership.
     */
    match /projects/{projectId}/eoiEmails/{eoiEmailId} {
      allow get: if isProjectReadOnly(get(/databases/$(database)/documents/projects/$(projectId)).data.members);
      allow list: if isProjectMember(get(/databases/$(database)/documents/projects/$(projectId)).data.members);

      allow create: if isProjectEditor(get(/databases/$(database)/documents/projects/$(projectId)).data.members);
      allow update: if isProjectEditor(get(/databases/$(database)/documents/projects/$(projectId)).data.members) && resource != null;
      allow delete: if isProjectOwner(get(/databases/$(database)/documents/projects/$(projectId)).data.members) && resource != null;
    }

    /**
     * @description
     * This rule governs access to RFP email data within a project.
     * Access is controlled via the 'members' map inherited from the parent project.
     * @path /projects/{projectId}/rfpEmails/{rfpEmailId}
     * @allow (create) User A can create an RFP email if they are an editor or owner of the project.
     * @allow (get) User A can read an RFP email if they are a member of the project.
     * @allow (update) User A can update an RFP email if they are an editor or owner of the project.
     * @allow (delete) User A can delete an RFP email if they are an owner of the project.
     * @deny (create) User A cannot create an RFP email if they are not an editor or owner of the project.
     * @deny (get) User A cannot read an RFP email if they are not a member of the project.
     * @deny (update) User A cannot update an RFP email if they are not an editor or owner of the project.
     * @deny (delete) User A cannot delete an RFP email if they are not an owner of the project.
     * @principle Enforces consistent access control based on project membership.
     */
    match /projects/{projectId}/rfpEmails/{rfpEmailId} {
      allow get: if isProjectReadOnly(get(/databases/$(database)/documents/projects/$(projectId)).data.members);
      allow list: if isProjectMember(get(/databases/$(database)/documents/projects/$(projectId)).data.members);

      allow create: if isProjectEditor(get(/databases/$(database)/documents/projects/$(projectId)).data.members);
      allow update: if isProjectEditor(get(/databases/$(database)/documents/projects/$(projectId)).data.members) && resource != null;
      allow delete: if isProjectOwner(get(/databases/$(database)/documents/projects/$(projectId)).data.members) && resource != null;
    }

    /**
     * @description
     * This rule governs access to RFP data within a project.
     * Access is controlled via the 'members' map inherited from the parent project.
     * @path /projects/{projectId}/rfps/{rfpId}
     * @allow (create) User A can create an RFP if they are an editor or owner of the project.
     * @allow (get) User A can read an RFP if they are a member of the project.
     * @allow (update) User A can update an RFP if they are an editor or owner of the project.
     * @allow (delete) User A can delete an RFP if they are an owner of the project.
     * @deny (create) User A cannot create an RFP if they are not an editor or owner of the project.
     * @deny (get) User A cannot read an RFP if they are not a member of the project.
     * @deny (update) User A cannot update an RFP if they are not an editor or owner of the project.
     * @deny (delete) User A cannot delete an RFP if they are not an owner of the project.
     * @principle Enforces consistent access control based on project membership.
     */
    match /projects/{projectId}/rfps/{rfpId} {
      allow get: if isProjectReadOnly(get(/databases/$(database)/documents/projects/$(projectId)).data.members);
      allow list: if isProjectMember(get(/databases/$(database)/documents/projects/$(projectId)).data.members);

      allow create: if isProjectEditor(get(/databases/$(database)/documents/projects/$(projectId)).data.members);
      allow update: if isProjectEditor(get(/databases/$(database)/documents/projects/$(projectId)).data.members) && resource != null;
      allow delete: if isProjectOwner(get(/databases/$(database)/documents/projects/$(projectId)).data.members) && resource != null;
    }

    /**
     * @description
     * This rule governs access to proposal data submitted by contractors.
     * The contractor owns the proposal. The ProjectId is denormalized.
     * @path /contractors/{contractorId}/proposals/{proposalId}
     * @allow (create) Contractor A can create a proposal under their ID.
     * @allow (get) Contractor A can read their own proposal.
     * @allow (update) Contractor A can update their own proposal.
     * @allow (delete) Contractor A can delete their own proposal.
     * @deny (create) Contractor A cannot create a proposal under Contractor B's ID.
     * @deny (get) Contractor A cannot read Contractor B's proposal.
     * @deny (update) Contractor A cannot update Contractor B's proposal.
     * @deny (delete) Contractor A cannot delete Contractor B's proposal.
     *
     */
    match /contractors/{contractorId}/proposals/{proposalId} {
      allow get: if isOwner(contractorId);
      allow list: if false; // Proposals are not listable

      allow create: if isOwner(contractorId) && request.resource.data.contractorId == contractorId;
      allow update: if isExistingOwner(contractorId) && request.resource.data.contractorId == resource.data.contractorId;
      allow delete: if isExistingOwner(contractorId);
    }

   /**
     * @description
     * This rule governs access to scorecard data.
     * Access is restricted to the contractor who owns the proposal.
     * @path /contractors/{contractorId}/proposals/{proposalId}/scorecards/{scorecardId}
     */
    match /contractors/{contractorId}/proposals/{proposalId}/scorecards/{scorecardId} {
      allow get: if isOwner(contractorId);
      allow list: if false;

      allow create: if isOwner(contractorId) && request.resource.data.proposalId == proposalId;
      allow update: if isExistingOwner(contractorId) && request.resource.data.proposalId == proposalId;
      allow delete: if isExistingOwner(contractorId);
    }

    /**
     * @description
     * This rule governs access to award recommendation data within a project.
     * Access is controlled via the 'members' map inherited from the parent project.
     * @path /projects/{projectId}/awardRecommendations/{awardRecommendationId}
     * @allow (create) User A can create an award recommendation if they are an editor or owner of the project.
     * @allow (get) User A can read an award recommendation if they are a member of the project.
     * @allow (update) User A can update an award recommendation if they are an editor or owner of the project.
     * @allow (delete) User A can delete an award recommendation if they are an owner of the project.
     * @deny (create) User A cannot create an award recommendation if they are not an editor or owner of the project.
     * @deny (get) User A cannot read an award recommendation if they are not a member of the project.
     * @deny (update) User A cannot update an award recommendation if they are not an editor or owner of the project.
     * @deny (delete) User A cannot delete an award recommendation if they are not an owner of the project.
     * @principle Enforces consistent access control based on project membership.
     */
    match /projects/{projectId}/awardRecommendations/{awardRecommendationId} {
      allow get: if isProjectReadOnly(get(/databases/$(database)/documents/projects/$(projectId)).data.members);
      allow list: if isProjectMember(get(/databases/$(database)/documents/projects/$(projectId)).data.members);

      allow create: if isProjectEditor(get(/databases/$(database)/documents/projects/$(projectId)).data.members);
      allow update: if isProjectEditor(get(/databases/$(database)/documents/projects/$(projectId)).data.members) && resource != null;
      allow delete: if isProjectOwner(get(/databases/$(database)/documents/projects/$(projectId)).data.members) && resource != null;
    }

    /**
     * @description
     * This rule governs access to feedback data within a project.
     * Access is controlled via the 'members' map inherited from the parent project.
     * @path /projects/{projectId}/feedback/{feedbackId}
     * @allow (create) User A can create feedback if they are an editor or owner of the project.
     * @allow (get) User A can read feedback if they are a member of the project.
     * @allow (update) User A can update feedback if they are an editor or owner of the project.
     * @allow (delete) User A can delete feedback if they are an owner of the project.
     * @deny (create) User A cannot create feedback if they are not an editor or owner of the project.
     * @deny (get) User A cannot read feedback if they are not a member of the project.
     * @deny (update) User A cannot update feedback if they are not an editor or owner of the project.
     * @deny (delete) User A cannot delete feedback if they are not an owner of the project.
     * @principle Enforces consistent access control based on project membership.
     */
    match /projects/{projectId}/feedback/{feedbackId} {
      allow get: if isProjectReadOnly(get(/databases/$(database)/documents/projects/$(projectId)).data.members);
      allow list: if isProjectMember(get(/databases/$(database)/documents/projects/$(projectId)).data.members);

      allow create: if isProjectEditor(get(/databases/$(database)/documents/projects/$(projectId)).data.members);
      allow update: if isProjectEditor(get(/databases/$(database)/documents/projects/$(projectId)).data.members) && resource != null;
      allow delete: if isProjectOwner(get(/databases/$(database)/documents/projects/$(projectId)).data.members) && resource != null;
    }

    /**
     * @description
     * This rule governs access to technical document data within a project.
     * Access is controlled via the 'members' map inherited from the parent project.
     * @path /projects/{projectId}/technicalDocuments/{technicalDocumentId}
     * @allow (create) User A can create a technical document if they are an editor or owner of the project.
     * @allow (get) User A can read a technical document if they are a member of the project.
     * @allow (update) User A can update a technical document if they are an editor or owner of the project.
     * @allow (delete) User A can delete a technical document if they are an owner of the project.
     * @deny (create) User A cannot create a technical document if they are not an editor or owner of the project.
     * @deny (get) User A cannot read a technical document if they are not a member of the project.
     * @deny (update) User A cannot update a technical document if they are not an editor or owner of the project.
     * @deny (delete) User A cannot delete a technical document if they are not an owner of the project.
     * @principle Enforces consistent access control based on project membership.
     */
    match /projects/{projectId}/technicalDocuments/{technicalDocumentId} {
      allow get: if isProjectReadOnly(get(/databases/$(database)/documents/projects/$(projectId)).data.members);
      allow list: if isProjectMember(get(/databases/$(database)/documents/projects/$(projectId)).data.members);

      allow create: if isProjectEditor(get(/databases/$(database)/documents/projects/$(projectId)).data.members);
      allow update: if isProjectEditor(get(/databases/$(database)/documents/projects/$(projectId)).data.members) && resource != null;
      allow delete: if isProjectOwner(get(/databases/$(database)/documents/projects/$(projectId)).data.members) && resource != null;
    }

    /**
     * @description
     * This rule governs access to metro code data.
     * Metro codes are publicly accessible.
     * @path /metroCodes/{metroCodeId}
     * @allow (get) Any user can read metro code data.
     * @allow (list) Any user can list metro code data.
     * @deny (create) No one can create metro codes via the client.
     * @deny (update) No one can update metro codes via the client.
     * @deny (delete) No one can delete metro codes via the client.
     * @principle Provides public read access to metro code information.
     */
    match /metroCodes/{metroCodeId} {
      allow get: if true;
      allow list: if true;

      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description
     * This rule governs access to contractor data.
     * Contractor data is publicly accessible.
     * @path /contractors/{contractorId}
     * @allow (get) Any user can read contractor data.
     * @allow (list) Any user can list contractor data.
     * @deny (create) No one can create contractors via the client.
     * @deny (update) No one can update contractors via the client.
     * @deny (delete) No one can delete contractors via the client.
     * @principle Provides public read access to contractor information.
     */
    match /contractors/{contractorId} {
      allow get: if true;
      allow list: if true;

      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
  }
}