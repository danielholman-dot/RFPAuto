/**
 * @file Firestore Security Rules
 * @description This ruleset enforces a strict user-ownership model for user profiles and allows public read access to projects (RFPs), contractors, and metro codes.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profile data. Access is restricted to the owner (the user with the matching UID).
 * - /rfps/{rfpId}: Stores project (RFP) data. Publicly readable, but only the owner can create, update, or delete.  It is assumed that each RFP document has an `ownerId` field.
 * - /rfps/{rfpId}/proposals/{proposalId}: Stores proposals submitted for a specific RFP.  Because RFPs are publicly readable, rules on this subcollection are complex. It is assumed each `proposal` has an `contractorId` field.
 * - /contractors/{contractorId}: Stores contractor data. Publicly readable, but only the owner can create, update, or delete. It is assumed that each contractor document has an `ownerId` field.
 * - /metro_codes/{metroCodeId}: Stores metro code data. Publicly readable, but only the owner can create, update, or delete. It is assumed that each metro code document has an `ownerId` field.
 *
 * Key Security Decisions:
 * - User listing is explicitly denied to protect user privacy.
 * - Public read access is granted to RFPs, contractors, and metro codes to facilitate discovery.
 * - Write access to RFPs, contractors, and metro codes is restricted to the owner.
 *
 * Denormalization for Authorization:
 * - The rules assume that the `Project`, `Contractor`, and `MetroCode` documents each contain an `ownerId` field that matches the UID of the user who created them.
 *   This is essential for enforcing owner-only write access.  This must be set by the client.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Prevents listing all users in the database.
     * @path /users
     * @allow N/A - Listing is always denied.
     * @deny list: Always. Listing all users is a security risk.
     * @principle Prevents unauthorized listing of users.
     */
    match /users {
        allow list: if false;
    }

    /**
     * @description Manages access to individual user documents. Only the user can read/write their own document.
     * @path /users/{userId}
     * @allow (get, create, update, delete) - User with UID 'user123' can read/write document with ID 'user123'.
     * @deny (get, create, update, delete) - User with UID 'user456' cannot read/write document with ID 'user123'.
     * @principle Enforces document ownership for user profiles.
     */
    match /users/{userId} {
      //  Helper function to check if the requesting user is the owner of the resource.
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      // Helper function to verify ownership and that the resource exists.
      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Manages access to RFPs (Projects). Allows public read access, but restricts writes to the owner.
     * @path /rfps/{rfpId}
     * @allow get, list: Any user can read/list RFPs.
     * @allow create: User with UID 'user123' can create an RFP with ownerId 'user123'.
     * @allow update, delete: User with UID 'user123' can update/delete an RFP where resource.data.ownerId == 'user123'.
     * @deny create: User with UID 'user123' cannot create an RFP with ownerId 'user456'.
     * @deny update, delete: User with UID 'user456' cannot update/delete an RFP where resource.data.ownerId == 'user123'.
     * @principle Enforces public read access with owner-only writes for RFPs.
     */
    match /rfps/{rfpId} {
      function isOwner(ownerId) {
        return request.auth != null && request.auth.uid == ownerId;
      }
      function isExistingOwner(ownerId) {
        return isOwner(ownerId) && resource != null;
      }

      allow get, list: if true;
      allow create: if isOwner(request.resource.data.ownerId);
      allow update: if isExistingOwner(resource.data.ownerId);
      allow delete: if isExistingOwner(resource.data.ownerId);
    }

    /**
     * @description Manages access to Proposals sub-collection. Access is restricted.
     * @path /rfps/{rfpId}/proposals/{proposalId}
     * @allow create: if request.auth.uid == request.resource.data.contractorId;
     * @allow get: if true;
     * @allow list: if true;
     * @deny update, delete: Always. Proposals should not be updated or deleted after submission.
     * @principle Limits proposal creation to the contractor and prohibits updates/deletions.
     */
    match /rfps/{rfpId}/proposals/{proposalId} {
      function isContractor(contractorId) {
        return request.auth != null && request.auth.uid == contractorId;
      }

      allow get, list: if true;
      allow create: if isContractor(request.resource.data.contractorId);
      allow update, delete: if false;
    }

    /**
     * @description Manages access to Contractors. Allows public read access, but restricts writes to the owner.
     * @path /contractors/{contractorId}
     * @allow get, list: Any user can read/list contractors.
     * @allow create: User with UID 'user123' can create a contractor with ownerId 'user123'.
     * @allow update, delete: User with UID 'user123' can update/delete a contractor where resource.data.ownerId == 'user123'.
     * @deny create: User with UID 'user123' cannot create a contractor with ownerId 'user456'.
     * @deny update, delete: User with UID 'user456' cannot update/delete a contractor where resource.data.ownerId == 'user123'.
     * @principle Enforces public read access with owner-only writes for contractors.
     */
    match /contractors/{contractorId} {
      function isOwner(ownerId) {
        return request.auth != null && request.auth.uid == ownerId;
      }
      function isExistingOwner(ownerId) {
        return isOwner(ownerId) && resource != null;
      }

      allow get, list: if true;
      allow create: if isOwner(request.resource.data.ownerId);
      allow update: if isExistingOwner(resource.data.ownerId);
      allow delete: if isExistingOwner(resource.data.ownerId);
    }

    /**
     * @description Manages access to Metro Codes. Allows public read access, but restricts writes to the owner.
     * @path /metro_codes/{metroCodeId}
     * @allow get, list: Any user can read/list metro codes.
     * @allow create: User with UID 'user123' can create a metro code with ownerId 'user123'.
     * @allow update, delete: User with UID 'user123' can update/delete a metro code where resource.data.ownerId == 'user123'.
     * @deny create: User with UID 'user123' cannot create a metro code with ownerId 'user456'.
     * @deny update, delete: User with UID 'user456' cannot update/delete a metro code where resource.data.ownerId == 'user123'.
     * @principle Enforces public read access with owner-only writes for metro codes.
     */
    match /metro_codes/{metroCodeId} {
      function isOwner(ownerId) {
        return request.auth != null && request.auth.uid == ownerId;
      }
      function isExistingOwner(ownerId) {
        return isOwner(ownerId) && resource != null;
      }

      allow get, list: if true;
      allow create: if isOwner(request.resource.data.ownerId);
      allow update: if isExistingOwner(resource.data.ownerId);
      allow delete: if isExistingOwner(resource.data.ownerId);
    }
  }
}