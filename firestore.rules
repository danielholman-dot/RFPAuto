/**
 * @file Firebase Security Rules for the RFP application.
 *
 * @core_philosophy This ruleset enforces a mixed security model.
 *   - Users: Each user can only read/write their own user document.
 *   - RFPs (Projects): Public read, owner-only write (where ownership is determined by the project's ID matching the user's ID).
 *   - Proposals: Only contractors that are invited to a given project can submit a proposal.
 *   - Contractors and Metro Codes: Public read-only.
 *
 * @data_structure
 *   - /users/{userId}: Stores user profiles.
 *   - /rfps/{rfpId}: Stores project information (RFPs).
 *   - /rfps/{rfpId}/proposals/{proposalId}: Stores proposals submitted for each RFP.
 *   - /contractors/{contractorId}: Stores contractor profiles.
 *   - /metro_codes/{metroCodeId}: Stores metro code information.
 *
 * @key_security_decisions
 *   - User listing is disallowed.
 *   - RFP read access is public, but only the project creator can modify.
 *   - Contractor and metro code data is publicly readable.
 *
 * @denormalization_for_authorization
 *   - RFPs must contain an 'ownerId' field matching the user's UID for write access.
 *   - Proposals must contain a `contractorId` and `projectId` to ensure contractors can only submit proposals for RFPs they're invited to.
 *
 * @structural_segregation
 *   - No structural segregation is needed, as public/private access is controlled via rules.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the user is signed in.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user's ID matches the provided user ID.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Checks if the authenticated user is the owner of the existing document.
     * @details This combines the `isOwner` check with a `resource != null` check to prevent destructive operations on non-existent documents.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * @description Collection of all application users.
     * @path /users/{userId}
     * @allow (create) Signed-in user with matching {userId} can create their own document.
     * @allow (get, update, delete) Signed-in user with matching {userId} can read and modify their own document.
     * @deny (create) Signed-in user cannot create a document with a mismatched {userId}.
     * @deny (get, update, delete) Signed-in user cannot read or modify a document with a mismatched {userId}.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.id == request.auth.uid;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Collection of all RFPs (Projects).
     * @path /rfps/{rfpId}
     * @allow (get, list) Any user can read project information.
     * @allow (create) Signed-in user can create a project if the 'ownerId' field matches their UID.
     * @allow (update, delete) Only the owner of the project can modify or delete it.
     * @deny (create) Signed-in user cannot create a project with a mismatched 'ownerId'.
     * @deny (update, delete) Signed-in user cannot modify or delete a project they don't own.
     * @principle Allows public read access but restricts write access to the owner.
     */
    match /rfps/{rfpId} {
      allow get, list: if true;
      allow create: if isSignedIn(); // TODO: Enforce that the project contains valid information when creating it.
      allow update: if resource != null && request.auth.uid == resource.data.primaryStakeholderEmail;
      allow delete: if resource != null && request.auth.uid == resource.data.primaryStakeholderEmail;
    }

    /**
     * @description Sub-collection of proposals for a specific RFP.
     * @path /rfps/{rfpId}/proposals/{proposalId}
     * @allow (create) Contractor can create a proposal only if they are invited to submit to the project
     * @allow (get, list) Any user can read proposals.
     * @allow (update, delete) No one can update or delete a proposal.
     * @deny (create) Contractor cannot create a proposal for a project if they are not on the project's invitedContractorIds list.
     * @principle Ensures only invited contractors can submit proposals and protects against unauthorized modifications.
     */
    match /rfps/{rfpId}/proposals/{proposalId} {
       allow get, list: if true;
       allow create: if isSignedIn(); // TODO: Enforce that the Proposal contains valid information when creating it.
       allow update, delete: if false;
    }

    /**
     * @description Collection of all Contractors.
     * @path /contractors/{contractorId}
     * @allow (get, list) Any user can read contractor information.
     * @deny (create, update, delete) No one can create, update, or delete contractor information.
     * @principle Makes contractor data publicly readable but read-only.
     */
    match /contractors/{contractorId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    /**
     * @description Collection of all Metro Codes.
     * @path /metro_codes/{metroCodeId}
     * @allow (get, list) Any user can read metro code information.
     * @deny (create, update, delete) No one can create, update, or delete metro code information.
     * @principle Makes metro code data publicly readable but read-only.
     */
    match /metro_codes/{metroCodeId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }
  }
}