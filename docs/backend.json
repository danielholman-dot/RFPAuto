{
  "entities": {
    "Project": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Project",
      "type": "object",
      "description": "Represents a project within the MARCUS Automation Suite.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the Project entity."
        },
        "projectName": {
          "type": "string",
          "description": "The name of the project."
        },
        "scopeOfWork": {
          "type": "string",
          "description": "A description of the work to be performed for the project."
        },
        "metroCodeId": {
          "type": "string",
          "description": "Reference to MetroCode. (Relationship: MetroCode 1:N Project)"
        },
        "contractorTypeId": {
          "type": "string",
          "description": "Reference to ContractorType. (Relationship: ContractorType 1:N Project)"
        },
        "estimatedBudget": {
          "type": "number",
          "description": "The estimated budget for the project."
        },
        "startDate": {
          "type": "string",
          "description": "The planned start date for the project.",
          "format": "date-time"
        },
        "technicalDocumentIds": {
          "type": "array",
          "description": "References to TechnicalDocuments. (Relationship: Project 1:N TechnicalDocument)",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "id",
        "projectName",
        "scopeOfWork",
        "metroCodeId",
        "contractorTypeId",
        "estimatedBudget",
        "startDate"
      ]
    },
    "MetroCode": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "MetroCode",
      "type": "object",
      "description": "Represents a metro code used for project location.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the MetroCode entity."
        },
        "code": {
          "type": "string",
          "description": "The metro code value."
        },
        "description": {
          "type": "string",
          "description": "A description of the metro area."
        }
      },
      "required": [
        "id",
        "code",
        "description"
      ]
    },
    "ContractorType": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ContractorType",
      "type": "object",
      "description": "Represents a type of contractor.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the ContractorType entity."
        },
        "name": {
          "type": "string",
          "description": "The name of the contractor type."
        }
      },
      "required": [
        "id",
        "name"
      ]
    },
    "Contractor": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Contractor",
      "type": "object",
      "description": "Represents a contractor who can bid on projects.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the Contractor entity."
        },
        "name": {
          "type": "string",
          "description": "The name of the contractor company."
        },
        "contactInformation": {
          "type": "string",
          "description": "Contact details for the contractor."
        },
        "metroCodeIds": {
          "type": "array",
          "description": "References to MetroCodes that the contractor serves. (Relationship: Contractor N:N MetroCode)",
          "items": {
            "type": "string"
          }
        },
        "contractorTypeIds": {
          "type": "array",
          "description": "References to ContractorTypes that the contractor is. (Relationship: Contractor N:N ContractorType)",
          "items": {
            "type": "string"
          }
        },
        "eoiSentDate": {
          "type": "string",
          "description": "The date the EOI was sent to the contractor.",
          "format": "date-time"
        },
        "proposalSubmissionDate": {
          "type": "string",
          "description": "The date the contractor submitted a proposal.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "name",
        "contactInformation"
      ]
    },
    "TechnicalDocument": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "TechnicalDocument",
      "type": "object",
      "description": "Represents a technical document associated with a project.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the TechnicalDocument entity."
        },
        "filename": {
          "type": "string",
          "description": "The name of the technical document file."
        },
        "uploadDate": {
          "type": "string",
          "description": "The date the technical document was uploaded.",
          "format": "date-time"
        },
        "fileSizeBytes": {
          "type": "number",
          "description": "The size of the file in bytes."
        }
      },
      "required": [
        "id",
        "filename",
        "uploadDate",
        "fileSizeBytes"
      ]
    },
    "Proposal": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Proposal",
      "type": "object",
      "description": "Represents a proposal submitted by a contractor for a project.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the Proposal entity."
        },
        "contractorId": {
          "type": "string",
          "description": "Reference to Contractor. (Relationship: Contractor 1:N Proposal)"
        },
        "projectId": {
          "type": "string",
          "description": "Reference to Project. (Relationship: Project 1:N Proposal)"
        },
        "submissionDate": {
          "type": "string",
          "description": "The date the proposal was submitted.",
          "format": "date-time"
        },
        "safetyScore": {
          "type": "number",
          "description": "The safety score assigned to the proposal."
        },
        "experienceScore": {
          "type": "number",
          "description": "The experience score assigned to the proposal."
        },
        "programmaticApproachScore": {
          "type": "number",
          "description": "The programmatic approach score assigned to the proposal."
        },
        "commercialExcellenceScore": {
          "type": "number",
          "description": "The commercial excellence score assigned to the proposal."
        },
        "innovativeSolutionsScore": {
          "type": "number",
          "description": "The innovative solutions score assigned to the proposal."
        },
        "missionCriticalExperienceScore": {
          "type": "number",
          "description": "The mission critical experience score assigned to the proposal."
        }
      },
      "required": [
        "id",
        "contractorId",
        "projectId",
        "submissionDate"
      ]
    },
    "Feedback": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Feedback",
      "type": "object",
      "description": "Represents feedback collected from stakeholders or contractors.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the Feedback entity."
        },
        "projectId": {
          "type": "string",
          "description": "Reference to Project. (Relationship: Project 1:N Feedback)"
        },
        "userId": {
          "type": "string",
          "description": "Reference to User. (Relationship: User 1:N Feedback)"
        },
        "feedbackText": {
          "type": "string",
          "description": "The text of the feedback provided."
        },
        "feedbackDate": {
          "type": "string",
          "description": "The date the feedback was submitted.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "projectId",
        "userId",
        "feedbackText",
        "feedbackDate"
      ]
    },
    "User": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "User",
      "type": "object",
      "description": "Represents a user of the MARCUS Automation Suite.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the User entity."
        },
        "email": {
          "type": "string",
          "description": "The user's email address.",
          "format": "email"
        },
        "name": {
          "type": "string",
          "description": "The user's full name."
        }
      },
      "required": [
        "id",
        "email",
        "name"
      ]
    }
  },
  "auth": {
    "providers": [
      "password",
      "anonymous"
    ]
  },
  "firestore": {
    "structure": [
      {
        "path": "/users/{userId}",
        "definition": {
          "entityName": "User",
          "schema": {
            "$ref": "#/backend/entities/User"
          },
          "description": "Stores user profile information. Only the user can read/write their own profile.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier of the user."
            }
          ]
        }
      },
      {
        "path": "/metro_codes/{metroCodeId}",
        "definition": {
          "entityName": "MetroCode",
          "schema": {
            "$ref": "#/backend/entities/MetroCode"
          },
          "description": "Stores metro code information. Publicly readable.",
          "params": [
            {
              "name": "metroCodeId",
              "description": "The unique identifier of the metro code."
            }
          ]
        }
      },
      {
        "path": "/contractor_types/{contractorTypeId}",
        "definition": {
          "entityName": "ContractorType",
          "schema": {
            "$ref": "#/backend/entities/ContractorType"
          },
          "description": "Stores contractor type information. Publicly readable.",
          "params": [
            {
              "name": "contractorTypeId",
              "description": "The unique identifier of the contractor type."
            }
          ]
        }
      },
      {
        "path": "/contractors/{contractorId}",
        "definition": {
          "entityName": "Contractor",
          "schema": {
            "$ref": "#/backend/entities/Contractor"
          },
          "description": "Stores contractor information. Publicly readable.",
          "params": [
            {
              "name": "contractorId",
              "description": "The unique identifier of the contractor."
            }
          ]
        }
      },
      {
        "path": "/projects/{projectId}",
        "definition": {
          "entityName": "Project",
          "schema": {
            "$ref": "#/backend/entities/Project"
          },
          "description": "Stores project information. Includes denormalized 'members' map for authorization independence.",
          "params": [
            {
              "name": "projectId",
              "description": "The unique identifier of the project."
            }
          ]
        }
      },
      {
        "path": "/projects/{projectId}/technical_documents/{technicalDocumentId}",
        "definition": {
          "entityName": "TechnicalDocument",
          "schema": {
            "$ref": "#/backend/entities/TechnicalDocument"
          },
          "description": "Stores technical documents associated with a project. Access controlled by project membership. Includes denormalized 'members' map for authorization independence.",
          "params": [
            {
              "name": "projectId",
              "description": "The unique identifier of the project."
            },
            {
              "name": "technicalDocumentId",
              "description": "The unique identifier of the technical document."
            }
          ]
        }
      },
      {
        "path": "/projects/{projectId}/proposals/{proposalId}",
        "definition": {
          "entityName": "Proposal",
          "schema": {
            "$ref": "#/backend/entities/Proposal"
          },
          "description": "Stores proposals submitted for a project. Access controlled by project membership. Includes denormalized 'members' map for authorization independence.",
          "params": [
            {
              "name": "projectId",
              "description": "The unique identifier of the project."
            },
            {
              "name": "proposalId",
              "description": "The unique identifier of the proposal."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/feedbacks/{feedbackId}",
        "definition": {
          "entityName": "Feedback",
          "schema": {
            "$ref": "#/backend/entities/Feedback"
          },
          "description": "Stores feedback provided by users. Only the user can read/write their own feedback.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier of the user."
            },
            {
              "name": "feedbackId",
              "description": "The unique identifier of the feedback."
            }
          ]
        }
      },
      {
        "path": "/roles_admin/{userId}",
        "definition": {
          "entityName": "roles_admin",
          "schema": {
            "$ref": "#/backend/entities/User"
          },
          "description": "Indicates if a user is an administrator. Existence of document grants admin privileges.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier of the user."
            }
          ]
        }
      }
    ],
    "reasoning": "The Firestore data structure is designed to support the MARCUS Automation Suite's core features while adhering to the principles of Authorization Independence, Structural Segregation, and Access Modeling.  It leverages path-based ownership for user-specific data and membership maps for collaborative data.  Denormalization is used to avoid `get()` calls in security rules, enhancing security and enabling atomic operations.\n\n**Authorization Independence:**  Crucially, where subcollections depend on parent attributes for authorization, these attributes are denormalized into the subcollection documents. For example, if access to `Proposals` depends on `Project` membership, the `members` map from the `Project` is copied into the `Proposal` documents. This eliminates the need for `get()` calls in security rules, ensuring authorization independence.\n\n**Structural Segregation:** Data with different access requirements are stored in separate collections.  Private user data (e.g., user profiles) are stored under `/users/{userId}`.  Global data (e.g., `MetroCodes`, `ContractorTypes`) are stored in root-level collections.  This segregation simplifies security rules by ensuring all documents within a collection share the same access control logic.\n\n**Access Modeling:**\n\n*   Path-based ownership is used for user-owned data: `/users/{userId}/feedbacks/{feedbackId}`. This ensures that only the user can access their feedback.\n*   Membership maps are used for collaborative data, such as `Projects`. The `members` map in the `Project` document specifies the roles of different users in the project. This map is then denormalized into subcollections like `Proposals` if access to proposals depends on project membership.\n\n**QAPs (Rules are not Filters):**\n\nThe structure supports secure `list` operations by:\n\n*   Segregating data based on access control needs. Only authorized users can access specific collections, preventing unauthorized listing of documents.\n*   Using membership maps and denormalization to determine access permissions without complex filtering in rules.\n*   Using a dedicated collection for storing global roles (e.g., `/roles_admin/{uid}`) to determine administrative privileges."
  }
}